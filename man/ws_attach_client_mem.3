.\" Automatically generated by Pandoc 1.19.2.4
.\"
.TH "WS_ATTACH_CLIENT_MEM" "3" "" "libdill" "libdill Library Functions"
.hy
.SH NAME
.PP
ws_attach_client_mem \- creates WebSocket protocol on the top of
underlying socket
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libdill.h>

int\ ws_attach_client_mem(
\ \ \ \ int\ s,
\ \ \ \ int\ flags,
\ \ \ \ const\ char*\ resource,
\ \ \ \ const\ char*\ host,
\ \ \ \ struct\ ws_storage*\ mem,
\ \ \ \ int64_t\ deadline);
\f[]
.fi
.SH DESCRIPTION
.PP
\f[B]WARNING: This is experimental functionality and the API may change
in the future.\f[]
.PP
WebSocket is a message\-based protocol defined in RFC 6455.
It can be used as a bidirectional communication channel for
communication with a web server.
.PP
This function instantiates WebSocket protocol on top of the underlying
bytestream protocol.
WebSocket protocol being asymmetric, client and server sides are
intialized in different ways.
This particular function initializes the client side of the connection.
.PP
The socket can be either text\- (\f[B]WS_TEXT\f[] flag) or binary\-
(\f[B]WS_BINARY\f[] flag) based.
Binary is the default.
When sending messages via \f[B]msend\f[] or \f[B]msendl\f[] these will
be typed based on the socket type.
When receiving messages via \f[B]mrecv\f[] or \f[B]mrecvl\f[]
encountering a message that doesn\[aq]t match the socket type results in
\f[B]EPROTO\f[] error.
.PP
If you want to combine text and binary messages you can do so by using
functions such as \f[B]ws_send\f[] and \f[B]ws_recv\f[].
.PP
\f[B]WS_NOHTTP\f[] flag can be combined with socket type flags.
If set, the protocol will skip the initial HTTP handshake.
In this case \f[B]resource\f[] and \f[B]host\f[] arguments won\[aq]t be
used and can be set to \f[B]NULL\f[].
.PP
Skipping HTTP handshake is useful when you want to do the handshake on
your own.
For example, if you want to implement custom WebSocket extensions or if
you want to write a multi\-protocol application where initial HTTP
handshake can be followed by different kinds of protocols (e.g.
HTML and WebSocket).
.PP
This function allows to avoid one dynamic memory allocation by storing
the object in user\-supplied memory.
Unless you are hyper\-optimizing use \f[B]ws_attach_client\f[] instead.
.PP
\f[B]s\f[]: Handle of the underlying socket.
It must be a bytestream protocol.
.PP
\f[B]flags\f[]: Flags.
See above.
.PP
\f[B]resource\f[]: HTTP resource to use.
.PP
\f[B]host\f[]: Virtual HTTP host to use.
.PP
\f[B]mem\f[]: The structure to store the newly created object in.
It must not be deallocated before the object is closed.
.PP
\f[B]deadline\f[]: A point in time when the operation should time out,
in milliseconds.
Use the \f[B]now\f[] function to get your current point in time.
0 means immediate timeout, i.e., perform the operation if possible or
return without blocking if not.
\-1 means no deadline, i.e., the call will block forever if the
operation cannot be performed.
.PP
The socket can be cleanly shut down using \f[B]ws_detach\f[] function.
.PP
This function is not available if libdill is compiled with
\f[B]\-\-disable\-sockets\f[] option.
.SH RETURN VALUE
.PP
In case of success the function returns newly created socket handle.
In case of error it returns \-1 and sets \f[B]errno\f[] to one of the
values below.
.SH ERRORS
.IP \[bu] 2
\f[B]EBADF\f[]: Invalid handle.
.IP \[bu] 2
\f[B]ECANCELED\f[]: Current coroutine was canceled.
.IP \[bu] 2
\f[B]ECONNRESET\f[]: Broken connection.
.IP \[bu] 2
\f[B]EINVAL\f[]: Invalid argument.
.IP \[bu] 2
\f[B]EMFILE\f[]: The maximum number of file descriptors in the process
are already open.
.IP \[bu] 2
\f[B]ENFILE\f[]: The maximum number of file descriptors in the system
are already open.
.IP \[bu] 2
\f[B]ENOMEM\f[]: Not enough memory.
.IP \[bu] 2
\f[B]ENOTSUP\f[]: The handle does not support this operation.
.IP \[bu] 2
\f[B]EPROTO\f[]: Underlying socket is not a bytestream socket.
.IP \[bu] 2
\f[B]ETIMEDOUT\f[]: Deadline was reached.
.SH EXAMPLE
.IP
.nf
\f[C]
struct\ ipaddr\ addr;
ipaddr_remote(&addr,\ "www.example.org",\ 80,\ 0,\ \-1);
int\ s\ =\ tcp_connect(&addr,\ \-1);
s\ =\ ws_attach_client(s,\ "/",\ "www.example.org",\ WS_TEXT,\ \-1);
ws_send(s,\ WS_TEXT,\ "Hello,\ world!",\ 13,\ \-1);
int\ flags;
char\ buf[256];
ssize_t\ sz\ =\ ws_recv(s,\ &flags,\ buf,\ sizeof(buf),\ \-1);
assert(flags\ &\ WS_TEXT);
s\ =\ ws_detach(s,\ \-1);
tcp_close(s,\ \-1);
\f[]
.fi
.SH SEE ALSO
.PP
\f[B]hclose\f[](3) \f[B]mrecv\f[](3) \f[B]mrecvl\f[](3)
\f[B]msend\f[](3) \f[B]msendl\f[](3) \f[B]now\f[](3)
\f[B]ws_attach_client\f[](3) \f[B]ws_attach_server\f[](3)
\f[B]ws_attach_server_mem\f[](3) \f[B]ws_detach\f[](3)
\f[B]ws_done\f[](3) \f[B]ws_recv\f[](3) \f[B]ws_recvl\f[](3)
\f[B]ws_request_key\f[](3) \f[B]ws_response_key\f[](3)
\f[B]ws_send\f[](3) \f[B]ws_sendl\f[](3) \f[B]ws_status\f[](3)
