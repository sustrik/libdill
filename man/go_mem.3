.\" Automatically generated by Pandoc 1.19.2.4
.\"
.TH "GO_MEM" "3" "" "libdill" "libdill Library Functions"
.hy
.SH NAME
.PP
go_mem \- launches a coroutine
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libdill.h>

int\ go_mem(
\ \ \ \ expression,
\ \ \ \ void*\ mem,
\ \ \ \ size_t\ memlen);
\f[]
.fi
.SH DESCRIPTION
.PP
This construct launches a coroutine on a user\-supplied stack.
The stack has no guard page and stack overflow will result in
overwriting memory.
.PP
\f[B]expression\f[]: Expression to evaluate as a coroutine.
.PP
\f[B]mem\f[]: Buffer to hold the coroutine\[aq]s stack.
The buffer doesn\[aq]t have to be aligned.
The function will take care of properly aligning the stack itself.
.PP
\f[B]memlen\f[]: Size of the \f[B]mem\f[] buffer.
.PP
The coroutine is executed concurrently, and its lifetime may exceed the
lifetime of the caller coroutine.
The return value of the coroutine, if any, is discarded and cannot be
retrieved by the caller.
.PP
Any function to be invoked as a coroutine must be declared with the
\f[B]coroutine\f[] specifier.
.PP
Use \f[B]hclose\f[] to cancel the coroutine.
When the coroutine is canceled all the blocking calls within the
coroutine will start failing with \f[B]ECANCELED\f[] error.
.PP
\f[I]WARNING\f[]: Coroutines will most likely work even without the
coroutine specifier.
However, they may fail in random non\-deterministic ways, depending on
the code in question and the particular combination of compiler and
optimization level.
Additionally, arguments to a coroutine must not be function calls.
If they are, the program may fail non\-deterministically.
If you need to pass a result of a computation to a coroutine, do the
computation first, and then pass the result as an argument.
Instead of:
.IP
.nf
\f[C]
go(bar(foo(a)));
\f[]
.fi
.PP
Do this:
.IP
.nf
\f[C]
int\ a\ =\ foo();
go(bar(a));
\f[]
.fi
.SH RETURN VALUE
.PP
In case of success the function returns handle of a bundle containing
the new coroutine.
In case of error it returns \-1 and sets \f[B]errno\f[] to one of the
values below.
.PP
For details on coroutine bundles see \f[B]bundle\f[] function.
.SH ERRORS
.IP \[bu] 2
\f[B]ECANCELED\f[]: Current coroutine was canceled.
.IP \[bu] 2
\f[B]EMFILE\f[]: The maximum number of file descriptors in the process
are already open.
.IP \[bu] 2
\f[B]ENFILE\f[]: The maximum number of file descriptors in the system
are already open.
.IP \[bu] 2
\f[B]ENOMEM\f[]: Not enough memory.
.SH EXAMPLE
.IP
.nf
\f[C]
coroutine\ void\ add(int\ a,\ int\ b)\ {
\ \ \ \ printf("%d+%d=%d\\n",\ a,\ b,\ a\ +\ b);
}

\&...
char\ mem[16384];
int\ h\ =\ go_mem(add(1,\ 2),\ mem,\ sizeof(mem));
\f[]
.fi
.SH SEE ALSO
.PP
\f[B]bundle\f[](3) \f[B]bundle_go\f[](3) \f[B]bundle_go_mem\f[](3)
\f[B]bundle_mem\f[](3) \f[B]bundle_wait\f[](3) \f[B]go\f[](3)
\f[B]hclose\f[](3) \f[B]yield\f[](3)
